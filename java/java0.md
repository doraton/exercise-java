# 面向对象

共计10题。

### Q1:谈-谈你对面向对象的理解

面向过程让计算机有步骤地顺序做- -件事，是过程化思维，使用面向过程语言开发大型项目，软件复用
和维护存在很大问题，模块之间耦合严重。面向对象相对面向过程更适合解决规模较大的问题，可以拆
解问题复杂度，对现实事物进行抽象并映射为开发对象，更接近人的思维。
例如开]这个动作，面向过程是open(Door door)，动宾结构，door 作为操作对象的参数传入方法,
方法内定义开门的具体步骤。面向对象的方式首先会定义一个类Door,抽象出门的属性(如尺寸、颜
色)和行为(如 open和close)，主谓结构。
面向过程代码松散，强调流程化解决问题。面向对象代码强调高内聚、低耦合，先抽象模型定义共性行
为，再解决实际问题。



### Q2:面向对象的三大特性?

封装是对象功能内聚的表现形式，在抽象基础上决定信息是否公开及公开等级，核心问题是以什么方式
暴漏哪些信息。主要任务是对属性、数据、敏感行为实现隐藏，对属性的访问和修改必须通过公共接口
实现。封装使对象关系变得简单，降低了代码耦合度，方便维护。
迪米特原则就是对封装的要求，即A模块使用B模块的某接口行为，对B模块中除此行为外的其他信
息知道得应尽可能少。不直接对public属性进行读取和修改而使用getter/setter方法是因为假设想在
修改属性时进行权限控制、日志记录等操作，在直接访问属性的情况下无法实现。如果将public的属性
和行为修改为private - -般依赖模块都会报错，因此不知道使用哪种权限时应优先使用private。
继承用来扩展-个类，子类可继承父类的部分属性和行为使模块具有复用性。继承是"is-a"关系， 可使
用里氏替换原则判断是否满足"is-a"关系，即任何父类出现的地方子类都可以出现。如果父类引用直接
使用子类引用来代替且可以正确编译并执行，输出结果符合子类场景预期，那么说明两个类符合里氏替
换原则。
多态以封装和继承为基础，根据运行时对象实际类型使同-行为具有不同表现形式。多态指在编译层面
无法确定最终调用的方法体，在运行期由jVM动态绑定，调用合适的重写方法。由于重载属于静态绑
定，本质上重载结果是完全不同的方法，因此多态一般专指重写。

### Q3:重载和重写的区别?

重载指方法名称相同，但参数类型个数不同，是行为水平方向不同实现。对编译器来说，方法名称和参
数列表组成了一个唯一键，称为方法签名，JVM通过方法签名决定调用哪种重载方法。不管继承关系如
何复杂，重载在编译时可以根据规则知道调用哪种目标方法，因此属于静态绑定。
JVM在重载方法中选择合适方法的顺序:①精确匹配。②基本数据类型自动转换成更大表示范围。③
自动拆箱与装箱。④子类向上转型。⑤可变参数。
重写指子类实现接口或继承父类时，保持方法签名完全相同，实现不同方法体，是行为垂直方向不同实
现。
元空间有一个方法表保存方法信息，如果子类重写了父类的方法，则方法表中的方法引用会指向子类实
现。父类引用执行子类方法时无法调用子类存在而父类不存在的方法。
重写方法访问权限不能变小，返回类型和抛出的异常类型不能变大，必须加@Override。



### Q4:类之间有哪些关系?



### Q5: Object 类有哪些方法?

equals:检测对象是否相等，默认使用==比较对象引用，可以重写equals方法自定义比较规则。
equals方法规范:自反性、对称性、传递性、-致性、对于任何非空引用x, x.equals(null) 返回
false.
hashCode:散列码是由对象导出的一个整型值，没有规律，每个对象都有默认散列码，值由对象存储
地址得出。字符串散列码由内容导出，值可能相同。为了在集合中正确使用，-般需要同时重写equals
和hashCode,要求equals相同hashCode必须相同，hashCode 相同equals未必相同，因此
hashCode是对象相等的必要不充分条件。
toString:打印对象时默认的方法，如果没有重写打印的是表示对象值的一个字符串。
clone: clone 方法声明为protected,类只能通过该方法克隆它自己的对象，如果希望其他类也能调用
该方法必须定义该方法为public。如果-个对象的类没有实现Cloneable接口，该对象调用clone方抛
出一个CloneNotSupport异常。默认的clone方法是浅拷贝，一般重写clone方法需要实现
Cloneable接口并指定访问修饰符为public。
finalize:确定一个对象死亡至少要经过两次标记，如果对象在可达性分析后发现没有与GC Roots连接
的引用链会被第-次标记，随后进行一-次筛选，条件是对象是否有必要执行finalize 方法。假如对象没
有重写该方法或方法已被虚拟机调用，都视为没有必要执行。如果有必要执行，对象会被放置在F-
Queue队列，由-条低调度优先级的Finalizer线程去执行。虛拟机会触发该方法但不保证会结束，这
是为了防止某个对象的finalize方法执行缓慢或发生死循环。只要对象在finalize方法中重新与引用链
上的对象建立关联就会在第二次标记时被移出回收集合。由于运行代价高昂且无法保证调用顺序，在
JDK 9被标记为过时方法，并不适合释放资源。
getClass:返回包含对象信息的类对象。
wait / notify / notifyAll:阻塞或唤醒持有该对象锁的线程。



### Q6:内部类的作用是什么，有哪些分类?

内部类可对同一包中其他类隐藏，内部类方法可以访问定义这个内部类的作用域中的数据，包括
private数据。
内部类是一个编译器现象，与虚拟机无关。编译器会把内部类转换成常规的类文件，用$分隔外部类名
与内部类名，其中匿名内部类使用数字编号，虚拟机对此一无所知。
静态内部类:属于外部类，只加载- -次。作用域仅在包内，可通过外部类名.内部类名直接访问，类内
只能访问外部类所有静态属性和方法。HashMap 的Node节点，ReentrantLock 中的Sync类,
ArrayList的SubList都是静态内部类。内部类中还可以定义内部类，如ThreadLoacl静态内部类
ThreadLoaclMap中定义了内部类Entry。
成员内部类:属于外部类的每个对象，随对象一起加载。 不可以定义静态成员和方法，可访问外部类的
所有内容。
局部内部类:定义在方法内，不能声明访问修饰符，只能定义实例成员变量和实例方法，作用范围仅在
声明类的代码块中。
匿名内部类:只用一次的没有名字的类，可以简化代码，创建的对象类型相当于new的类的子类类
型。用于实现事件监听和其他回调。

### Q7:访问权限控制符有哪些?

### Q8:接口和抽象类的异同?

接口和抽象类对实体类进行更高层次的抽象，仅定义公共行为和特征。



### Q9:接口和抽象类应该怎么选择?

抽象类体现is-a关系，接口体现can-do关系。与接口相比，抽象类通常是对同类事物相对具体的抽
象。
抽象类是模板式设计，包含-组具体特征，例如某汽车，底盘、控制电路等是抽象出来的共同特征，但
内饰、显示屏、座椅材质可以根据不同级别配置存在不同实现。
接口是契约式设计，是开放的，定义了方法名、参数、返回值、抛出的异常类型，谁都可以实现它，但
必须遵守接口的约定。例如所有车辆都必须实现刹车这种强制规范。
接口是顶级类，抽象类在接口下面的第二层，对接口进行了组合，然后实现部分接口。当纠结定义接口
和抽象类时，推荐定义为接口，遵循接口隔离原则，按维度划分成多个接口，再利用抽象类去实现这
些，方便后续的扩展和重构。
例如Plane和Bird都有fly 方法，应把fly定义为接口，而不是抽象类的抽象方法再继承，因为除了fly .
行为外Plane和Bird间很难再找到其他共同特征。



### Q10:子类初始化的顺序

①父类静态代码块和静态变量。②子类静态代码块和静态变量。③父类普通代码块和普通变量。④
父类构造方法。⑤子类普通代码块和普通变量。⑥子类构造方法。