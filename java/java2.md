# I/O

共计6道

### Q1:同步/异步/阻塞/非阻塞I0的区别?

同步和异步是通信机制，阻塞和非阻塞是调用状态。
同步I0是用户线程发起I0请求后需要等待或轮询内核10操作完成后才能继续执行。异步10是用户线
程发起I0请求后可以继续执行，当内核I0操作完成后会通知用户线程，或调用用户线程注册的回调函
数。
阻塞10是10操作需要彻底完成后才能返回用户空间。非阻塞I0是I0操作调用后立即返回一个状态
值，无需等I0操作彻底完成。

### Q2:什么是BIO?

BIO是同步阻塞式I0, JDK1.4 之前的I0模型。服务器实现模式为一个连接请求对应一个线程，服务器
需要为每一个客户端]请求创建一个线程，如果这个连接不做任何事会造成不必要的线程开销。可以通过
线程池改善，这种10称为伪异步I0。适用连接数目少且服务器资源多的场景。

### Q3:什么是NIO?

NIO是JDK1.4引入的同步非阻塞I0。服务器实现模式为多个连接请求对应一个线程，客户端连接请求
会注册到一个多路复用器Selector，Selector 轮询到连接有I0请求时才启动一个线程处理。适用连接
数目多且连接时间短的场景。
同步是指线程还是要不断接收客户端连接并处理数据，非阻塞是指如果-个管道没有数据，不需要等
待，可以轮询下一-个管道。
核心组件:
●Selector: 多路复用器，轮询检查多个Channel的状态，判断注册事件是否发生，即判断
Channel是否处于可读或可写状态。使用前需要将Channel注册到Selector,注册后会得到一个
SelectionKey，通过SelectionKey获取Channel和Selector相关信息。
●Channel: 双向通道，替换了BIO中的Stream流，不能直接访问数据，要通过Buffer来读写数
据，也可以和其他Channel交互。
●Buffer: 缓冲区，本质是一块可读写数据的内存，用来简化数据读写。Buffer三个重要属性:
position'下次读写数据的位置，limit 本次读写的极限位置，capacity 最大容量。
0 f1ip将写转为读，底层实现原理把position置0，并把limit设为当前的position值。
。clear将读转为写模式(用于读完全部数据的情况，把position置0, limit设为
capacity)。
o compact 将读转为写模式(用于存在未读数据的情况，让position指向未读数据的下一
个)。
。通道方向和Buffer方向相反，读数据相当于向Buffer写，写数据相当于从Buffer读。
使用步骤:向Buffer写数据，调用flip方法转为读模式,从Buffer中读数据，调用clear 或
compact方法清空缓冲区。

### Q4:什么是AIO?

AIO是jDK7引入的异步非阻塞I0。服务器实现模式为一个有效请求对应- -个线程，客户端的I0请求.
都是由操作系统先完成I0操作后再通知服务器应用来直接使用准备好的数据。适用连接数目多且连接
时间长的场景。
异步是指服务端线程接收到客户端管道后就交给底层处理I0通信，自己可以做其他事情，非阻塞是指客
户端有数据才会处理，处理好再通知服务器。
实现方式包括通过Future的get方法进行阻塞式调用以及实现CompletionHandler接口，重写请求
成功的回调方法completed和请求失败回调方法failed 。

### Q5: java.io 包下有哪些流?

主要分为字符流和字节流，字符流-般用于文本文件， 字节流一般用于图像或其他文件 。
字符流包括了字符输入流Reader和字符输出流Writer,字节流包括了字节输入流InputStream和字节
输出流OutputStream。字符流和字节流都有对应的缓冲流，字节流也可以包装为字符流，缓冲流带有
一个8KB的缓冲数组，可以提高流的读写效率。除了缓冲流外还有过滤流FilterReader、字符数组流
CharArrayReader、字节数组流ByteArrayInputStream、文件流FileInputStream等。

### Q6:序列化和反序列化是什么?

Java对象JVM退出时会全部销毁，如果需要将对象及状态持久化，就要通过序列化实现，将内存中的
对象保存在二进制流中，需要时再将二进制流反序列化为对象。对象序列化保存的是对象的状态，因此
属于类属性的静态变量不会被序列化。
常见的序列化有三种:
●Java 原生序列化
实现Serializabale 标记接口，Java 序列化保留了对象类的元数据(如类、 成员变量、继承类
信息)以及对象数据，兼容性最好，但不支持跨语言，性能- -般。序列化和反序列化必须保持序列
化ID的一-致，- -般使用private static final 1ong serialversionuId 定义序列化ID,
如果不设置编译器会根据类的内部实现自动生成该值。如果是兼容升级不应该修改序列化ID,防
止出错，如果是不兼容升级则需要修改。
●Hessian序列化
Hessian序列化是- -种支持动态类型、跨语言、基于对象传输的网络协议。Java 对象序列化的二进
制流可以被其它语言反序列化。Hessian 协议的特性:①自描述序列化类型，不依赖外部描述文
件，用一个字节表示常用基础类型，极大缩短二进制流。②语言无关，支持脚本语言。③协议简
单，比Java原生序列化高效。Hessian 会把复杂对象所有属性存储在-一个 Map中序列化，当父类
和子类存在同名成员变量时会先序列化子类再序列化父类，因此子类值会被父类覆盖。
●JSON序列化
JSON序列化就是将数据对象转换为JSON字符串，在序列化过程中抛弃了类型信息，所以反序列
化时只有提供类型信息才能准确进行。相比前两种方式可读性更好，方便调试。
序列化通常会使用网络传输对象，而对象中往往有敏感数据，容易遭受攻击，Jackson 和fastjson等都
出现过反序列化漏洞，因此不需要进行序列化的敏感属性传输时应加上transient关键字。transient 的
作用就是把变量生命周期仅限于内存而不会写到磁盘里持久化，变量会被设为对应数据类型的零值。